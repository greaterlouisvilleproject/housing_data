---
title: "Rental Instability in Louisville"
author: "Greater Louisville Project"
date: '2020-10-18'
output:
  html_document:
    toc: yes
    toc_float: yes
    code_folding: hide
---

# Introduction

This recreates the Urban Institute's [Emergency Rental Assistance Priority Index](https://www.urban.org/features/where-prioritize-emergency-rental-assistance-keep-renters-their-homes) for Louisville. The original index compares Louisville to the rest of Kentucky. At Greater Louisville Project, we think the more appropriate comparison is to our other peer cities. While the maps below show Louisville, the index values are based on a comparison to all census tracts in the core counties of our peer cities. 

In addition to the indexes, the indicators that make up the indexes are also mapped below. Navigation is based on tabs, so clicking on the small blue titles brings up the map related to each title. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

```{r}
library(tidyverse)
library(rgdal)
library(sf)
library(viridis)
library(magrittr)

df <- read_csv("housing_index_raw.csv")

# Filter to just peers
df_peer <- df %>% 
  filter(county_fips %in% c("1073", "18097", "21111", "26081", "29095", "29189",
                            "29510", "31055", "37081", "37119", "39049", "39061",
                            "40109", "40143", "45045", "47037", "47093", "47157")) %>%
  select(-contains("z_score"), -contains("index")) #drop index and z_score terms so we can recreate them

# Make z scores
make_z <- function(x){
  x <- (x - mean(x)) / sd(x)
}

df_z <- df_peer %>%
  mutate(across(where(is.numeric), make_z, .names = "z_{.col}"))

df_index <- df_z %>%
  mutate(
    housing_instability_index = z_perc_poverty_12mnth * .2 + z_perc_renters * .2 + z_perc_cost_burdened_under_35k * .2 + z_perc_overcrowding_renter_1.50_or_more * .2 + z_perc_unemployed_laborforce * .2,
    covid_index = z_perc_no_hinsure * .5 + z_perc_low_income_jobs_lost * .5,
    equity_index = z_perc_person_of_color * .5 + z_perc_30hamfi * .167 + z_perc_public_assistance * .167 + z_perc_foreign_born * .167,
    overall_index = housing_instability_index * .5 + covid_index * .1 + equity_index * .4
  )
```

# Rental Insecurity Index {.tabset .tabset-fade .tabset-pills}

```{r}
jfco_shp <- readOGR("JC Tracts", layer = "JC Tracts",
                     GDAL1_integer64_policy = TRUE, verbose = FALSE)

jfco_sf <- st_as_sf(jfco_shp) %>%
  mutate(GEOID = str_sub(GEO_ID, start = -11))

jfco_index <- df_index %>% 
  filter(county_fips == "21111") 

# Urban institute includes a greyed out flag for tracts without enough data
# It's easier to set the values to NA because the graphing framework has the ability to easily assign NA a different color
jfco_index <- jfco_index %>%
  mutate(across(where(is.numeric), ~if_else(jfco_index$grayed_out == 1, NA_real_, .)))
         
jfco_sf <- full_join(jfco_sf, jfco_index, by = "GEOID")

# Transform the percents
mult100 <- function(x){
  x <- x * 100
}

jfco_sf <- jfco_sf %>%
  mutate(across(starts_with("perc_"), mult100))

make_map <- function(indicator, title = "", legend = "", caption = ""){
  ggplot(jfco_sf) + 
  geom_sf(aes(fill={{ indicator }} )) +
  scale_fill_viridis(na.value = "grey", name = legend) +
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        panel.border = element_blank()) +
  labs(title = title,
       caption = caption)
}

make_map(overall_index, title = "Rental Insecurity Index", 
         legend = "Compared to \n other tracts", 
         caption = "This is the Urban Institute's Emergency Rental Assistance Priority Index modified \nto compare Louisville to its peer cities (instead of to other areas in Kentucky). \n Greyed out areas had insufficient data for the index")
```

You can flip through the tabs below to see each of the three subindexes that make up the overall rental index.

## Housing Instability Subindex

- Share of people living in poverty
- Share of renter-occupied housing units
- Share of severely cost-burdened low-income renters
- Share of severely overcrowded households
- Share of unemployed people

```{r}
make_map(housing_instability_index, title = "Housing Instability Subindex", 
         legend = "Compared to \n other tracts", 
         caption = "This is the Urban Institute's Housing Instability subindex modified \nto compare Louisville to its peer cities (instead of to other areas in Kentucky). \n Greyed out areas had insufficient data for the index")
```

## Covid 19 Impact Subindex

- Share of adults without health insurance
- Share of low-income jobs lost to Covid-19

```{r}
make_map(covid_index, title = "Covid Instability Subindex", 
         legend = "Compared to \n other tracts", 
         caption = "This is the Urban Institute's Covid Instability subindex modified \nto compare Louisville to its peer cities (instead of to other areas in Kentucky). \n Greyed out areas had insufficient data for the index")
```

## Equity Subindex

- Share of people of color
- Share of extremely low-income renter households
- Share of households receiving public assistance
- Share of people born outside the United States

```{r}
make_map(equity_index, title = "Equity Subindex", 
         legend = "Compared to \n other tracts", 
         caption = "This is the Urban Institute's Equity subindex modified \nto compare Louisville to its peer cities (instead of to other areas in Kentucky). \n Greyed out areas had insufficient data for the index")
```

# Housing Instability Indicators {.tabset .tabset-fade .tabset-pills}

## Poverty

```{r}
make_map(perc_poverty_12mnth, title = "Poverty", 
         legend = "Percent", 
         caption = "Data from Urban Institute")
```

## Percent Renting

```{r}
make_map(perc_renters, title = "Percent of Renter Occupied Housing Units", 
         legend = "Percent", 
         caption = "Data from Urban Institute")
```

## Cost-burdened housholds

```{r}
make_map(perc_cost_burdened_under_35k, title = "Costburdened Households making under 35k", 
         legend = "Percent", 
         caption = "Data from Urban Institute")
```

## Overcrowding

```{r}
make_map(perc_overcrowding_renter_1.50_or_more, title = "Overcrowding in Rental Housing", 
         legend = "Percent", 
         caption = "Data from Urban Institute")
```

## Unemployed

```{r}
make_map(perc_unemployed_laborforce, title = "Unemployment", 
         legend = "Percent", 
         caption = "Data from Urban Institute")
```

# Covid Indicators {.tabset .tabset-fade .tabset-pills}

## No Health Insurance

```{r}
make_map(perc_no_hinsure, title = "No Health Insurance", 
         legend = "Percent", 
         caption = "Data from Urban Institute")
```

## Low Income Jobs Lost to Covid

```{r}
make_map(perc_low_income_jobs_lost, title = "Low Income Jobs Lost to Covid", 
         legend = "Percent", 
         caption = "Data from Urban Institute")
```

# Equity Index {.tabset .tabset-fade .tabset-pills}

## Percent PoC

```{r}
make_map(perc_person_of_color, title = "Percent Persons of Color", 
         legend = "Percent", 
         caption = "Data from Urban Institute")
```

## Extremely Low Income
```{r}
make_map(perc_30hamfi, title = "Extremely Low Income", 
         legend = "Percent", 
         caption = "Data from Urban Institute")
```

## Public Assistance
```{r}
make_map(perc_public_assistance, title = "Recieving Public Assistance", 
         legend = "Percent", 
         caption = "Data from Urban Institute")
```

## Foreign Born
```{r}
make_map(perc_foreign_born, title = "Foreign Born", 
         legend = "Percent", 
         caption = "Data from Urban Institute")
```

# Peer City Data

```{r}
#Data was pulled in Python file get_data.py and written to .csv
df <- read_csv("low_income_renters.csv")

## This code is modified from the urban institute: https://github.com/UrbanInstitute/covid-rental-risk-index/blob/master/scripts/01_generate_index_variables.R

# Calculate percent of households making under 35k who pay more than 50% of their
# income on rent
df <- df %>%
  # select ACS table variables w/ attached GEOID
  select(
    NAME,
    # These are all the peolpe making under 35k (denominator)
    B25074_002E,
    B25074_011E,
    B25074_020E,
    # These are all the people making under 35k who pay more than 50% of their income on rent (numerator)
    B25074_009E,
    B25074_018E,
    B25074_027E,
    # These are the people making under 35k for whom this metric wasn't computed
    # and they therefore need to be subtracted from the denominator
    B25074_010E,
    B25074_019E,
    B25074_028E
  )  %>%
  #rename both county and city to just St. Louis
  mutate(NAME = if_else(str_detect(NAME, "St. Louis"), "St. Louis", NAME)) %>%
  group_by(NAME) %>%
  #use summarize across instead to save space and make reusable in a function
  summarize(
    B25074_002E = sum(B25074_002E),
    B25074_011E = sum(B25074_011E),
    B25074_020E = sum(B25074_020E),
    B25074_009E = sum(B25074_009E),
    B25074_018E = sum(B25074_018E),
    B25074_027E = sum(B25074_027E),
    B25074_010E = sum(B25074_010E),
    B25074_019E = sum(B25074_019E),
    B25074_028E = sum(B25074_028E)
  ) %>%
  # create cost burden variable w/ calculation
  mutate(
    perc_cost_burdened_under_35k = (B25074_009E + B25074_018E + B25074_027E) /
      (
        B25074_002E + B25074_011E + B25074_020E - B25074_010E - B25074_019E -
          B25074_028E
      ),
    #cd add
    perc_cost_burdened_under_35k =
      if_else(
        B25074_002E + B25074_011E + B25074_020E == 0,
        0,
        perc_cost_burdened_under_35k
      )
  )

# Clean up for graph
df <- df %>%
  mutate(city = recode(NAME,
                       `Davidson County, Tennessee` = "Nashville",
                       `Douglas County, Nebraska` = "Omaha",
                       `Franklin County, Ohio` = "Columbus",
                       `Greenville County, South Carolina` = "Greenville",
                       `Guilford County, North Carolina` = "",
                       `Hamilton County, Ohio` = "Cincinnati",
                       `Jackson County, Missouri` = "",
                       `Jefferson County, Alabama` = "Birmingham",
                       `Jefferson County, Kentucky` = "Louisville",
                       `Kent County, Michigan` = "Grand Rapids",
                       `Knox County, Tennessee` = "Knoxville",
                       `Marion County, Indianapolis` = "Indianapolis",
                       `Mecklenburg County, North Carolina` = "",
                       `Oklahoma County, Oklahoma` = "Oklahoma City",
                       `Shelby County, Tennessee` = "Memphis",
                       `Tulsa County, Oklahoma` = "Tulsa"),
         perc_cost_burdened_under_35k = 100 * perc_cost_burdened_under_35k) 
```

```{r}
# set up fonts
library(showtext)
showtext_auto()

font_add("Montserrat", "Montserrat/Montserrat-Regular.ttf")
font_add("Montserrat Bold", "Montserrat/Montserrat-SemiBold.ttf")

ranking <- function(df, var, plot_title = "",
                    year = NULL, sex = "total", race = "total",
                    order = "Descending",
                    y_title = "Percent", caption_text = "", subtitle_text = "",
                    bar_label = TRUE, sigfig = 3, accuracy = 0.1,
                    label_function, alternate_text = NULL,
                    ranking_colors = TRUE, text_size){
  # Copy variable var to a new column for use with the '$' operator
  var <- dplyr:::tbl_at_vars(df, vars(!!enquo(var)))
  df$var <- df[[var]]
  # Filter to sex, race, and year
  if ("sex" %in% names(df)) df <- df[df$sex == sex,]
  if ("race" %in% names(df)) df <- df[df$race == race,]
  if("year" %in% names(df)) {
    if (is.null(year)) year <- max(years_in_df(df, var))
    df <- df[df$year %in% year,]
    if (length(year) > 1) {
      df %<>%
        group_by_at(df %cols_in% c("MSA", "FIPS")) %>%
        summarise(var = mean(var, na.rm = TRUE)) %>%
        ungroup()
    }
  }
  # Add peer data if not already present
  # if (df_type(df) %in% c("FIPS", "MSA") & "current" %not_in% names(df)) df %<>% pull_peers(add_info = T)
  
  # Sort according to order parameter
  if (order %in% c("descending", "Descending")) df %<>% arrange(desc(var))
  if (order %in% c("ascending", "Ascending"))   df %<>% arrange(var)
  df %<>% filter(!is.na(var))
  # Create numbered city labels for left side of graph
  df %<>%
    mutate(
      rank = row_number(),
      names = paste0(rank, ". ", city))
  # Set bar colors
  if (ranking_colors) {
    # color_values <- c("#96ca4f", "#ffd600", "#db2834")
    # color_names <- c("green", "yellow", "red")
    # if (order %in% c("descending", "Descending")) {color_names  = rev(color_names)}
    # 
    # breaks <- classInt::classIntervals(na.omit(df$var), 3, style = "jenks")
    # df$color <- NA
    # df$color[df$var <= breaks$brks[2]] <- color_names[1]
    # df$color[df$var > breaks$brks[2] & df$var <= breaks$brks[3]] <- color_names[2]
    # df$color[df$var > breaks$brks[3]] <- color_names[3]
    
    color_values <- c("#d63631", "#323844")
    color_names <- c("gray", "red")
    
    df$color <- "gray"
    df$color[df$city == "Louisville"] <- "red"
  } else {
    df$color <- "blue"
    color_values <- "#f58021"
    color_names <- "blue"
  }
  if (order %in% c("descending", "Descending")) color_values = rev(color_values)
  # Create numeric labels

  label_text <- df$var %>% signif(sigfig) %>% scales::comma(accuracy = accuracy)
    
  # Set text format, highlight and italicise Louisville text, highlight Louisville bar
  df$textcolor <- "#000000"
  df$textcolor[df$city == "Louisville"] <- "#000000"
  
  df$textfont <- "Montserrat"
  df$textfont[df$city == "Louisville"] <- "Montserrat Bold"
  
  label_color_names <- c("white", "black")
  label_color_values <- c("#000000", "#ffffff")
  
  df$label_color <- "white"
  df$label_color[df$city == "Louisville"] <- "black"
  #df$linecolor <- "#ffffff"
  #df$linecolor[df$city == "Louisville"] <- "#00a9b7"
  df$lou <- if_else(df$city == "Louisville", 1, 0)
  df$text_alignment <- 1.1
  if (!is.null(alternate_text)) df$text_alignment[df$rank %in% alternate_text] <- -0.1
  ### PLOT GRAPH
  
  # Initial plot
  p <- ggplot(data = df,
              aes(x = factor(names, levels = rev(names)),
                  y = var,
                  fill  = factor(color, levels = color_names, ordered = TRUE)))
  p <- p + guides(fill = FALSE, color = FALSE)
  # Add bars
  p <- p +
    geom_bar(stat = "identity",
             size = text_size) +
    coord_flip() +
    ggthemes::theme_tufte()
  p <- p + scale_fill_manual(values = color_values)
  #p <- p + scale_color_manual(values = c("#ffffff", "#00a9b7"))
  # Add features
  title_scale <- min(1, 48 / nchar(plot_title))
  p <- p + theme(text = element_text(family = "Montserrat"),
                 plot.title = element_text(size = 12 * title_scale * text_size, hjust = 0.5, margin = margin(b = 10, unit = "pt")),
                 axis.text.y = element_text(hjust = 0,
                                            size = 10 * text_size, 
                                            color = rev(df$textcolor),
                                            family = rev(df$textfont)),
                 axis.title.x = element_text(size = 10 * text_size),
                 axis.ticks = element_blank(),
                 axis.text.x = element_blank(),
                 plot.caption = element_text(size = 5 * text_size, lineheight = 0.5))
  if(subtitle_text != ""){
    p <- p + theme(plot.subtitle = element_text(hjust = 0.5, size = 5 * text_size)) +
      labs(subtitle = subtitle_text)
  }
  # Add numeric labels to bars based on bar_label parameter
  if (y_title != "" & bar_label) {
    p <- p + geom_text(aes(label = label_text, 
                           hjust = text_alignment, 
                           color = factor(label_color),
                           family = textfont),
                       size = 5 * text_size) +
       scale_colour_manual(values=c("#000000", "#ffffff"))
    }
  # Add vertical line to the left side of the bars based on the h_line parameter
  if (min(df$var, na.rm = TRUE) < 0) p <- p + geom_hline(yintercept = 0, linetype = "longdash", size = 2)
  # Add remaining text
  p <- p + labs(title = plot_title, y = y_title,
                x = "", caption = caption_text)
  
  p
}

```

```{r}
plt_cost_burdened <- ranking(df, "perc_cost_burdened_under_35k", text_size = 1, order = "ascending")

plt_cost_burdened
```

